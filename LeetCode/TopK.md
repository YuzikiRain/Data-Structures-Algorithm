## 先排序，再查找

先用任意排序算法对集合排序后，再查找前k个即可。复杂度取决于排序算法。一般来说时间复杂度是O(n^2)

## 优化：仅找出前k大元素就停止排序

对于简单选择排序、冒泡排序，每次遍历都可以确定第k个元素，因此只需要执行`n*k`次即可。

## 大顶堆

前k个元素之间的顺序也不需要保证的话，可以考虑使用。

-   先生成大小为k的大顶堆，
-   然后再对剩余的n-k个元素进行插入，但不扩容，多出来的元素直接舍弃。
-   最后得到的大小为k的大顶堆中的所有元素即为前k大元素，不需要进行堆排序。

## 快速排序

**减治法**（Reduce&Conquer），把一个大的问题，转化为若干个子问题（Reduce），这些子问题中“**只**”解决一个，大的问题便随之解决（Conquer）。这里的关键词是**“只”**。类似的问题有二分查找。

和分治法不同，分治法需要解决所有子问题。

这里利用快排每轮确定一个pivot的索引，使得两边的序列刚好分别比pivot大或小的特点。

-   每轮排序都能找到一个min<=pivot<=max的基准点，将整个数组分割为小于pivot以及大于或等于pivot的两个序列，并确定pivot所在索引`index`。
-   如果k小于（或者是大于）上一轮的索引`index`，最终排序是从左往右递增的，则k在左边（或者右边）的序列，只需要对该序列继续快排即可，另外一边不用管。

-   **直到pivot的索引刚好为k**，此轮交换完成后，其中一个序列的元素刚好是于或等于pivot（第k大元素）

## 参考

[(2条消息) 拜托，面试别再问我TopK了！！！_架构师之路_的博客-CSDN博客](https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278)
