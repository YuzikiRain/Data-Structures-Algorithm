

### 直接迭代法
    void Fib(int n)
    {
        if(n <= 2)
        {
            return n;
        }
        else
        {
            return Fib(n - 1) + Fib(n - 2);
        }
    }


### 改进的迭代法（利用之前求得的结果）
前一种解法可形象地分解为一颗二叉树来表示，可以看出树中有很多重复的节点，计算f(n)一共需要2^n次，时间复杂度高达O(2^n)，避免这些计算是优化的主要途径。　　

    　　　　　　　　　　f(10)　　
    　　　　　　　　/　　　　　\　　
    　　　　　　f(9)　　　　　f(8)　　
    　　　　　/　　　\　　　　/    \　　
       　　f(8)     f(7)　f(7)　　f(6)　　
      　　/   \     /   \　　
    　　f(7)  f(6) f(6) f(5)　　

如果去除这些重复节点，那么只需要n次即可，时间复杂度仅O(n)。
![Avatar](./pictures/Fib求和.jpg)
可看出，f(0)+f(1)=f(2), f(1)+f(2)=f(3), ..., f(n-2)+f(n-1)=f(n),有如下代码：

    void Fib(int n)
    {
        if(n <= 2)
        {
            return n;
        }
        else
        {
            int f1 = 1;
            int f2 = 1;
            int i = 1;
            while(i < n)
            {
                int sum = f1 + f2;
                int temp = f1;
                f1 = sum;
                f2 = f1;
                i++;
            }
            return f1;
        }
    }

发现其实不需要中间变量temp，且可以将n<=2的情形与n>2的情形合并，有如下代码：

    void Fib(int n)
    {
        int f1 = 1;
        int f2 = 1;
        int i = 1;
        while(i++ < n)
        {
            f1 = f1 + f2;
            f2 = f1 - f2;
        }
        return f1;
    }
迭代执行n次，时间复杂度为O(n)，仅需2个int的空间，空间复杂度为O(1)。


### 问题变种1：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法

对于前2级台阶有2种跳法：直接跳2级或先跳一级再跳一级。
把n级台阶时的跳法看成是n的函数，记为f(n)。如果第一次选择跳1级，那么剩下n-1级台阶，即有f(n-1)种跳法去完成这n-1级台阶，同理可得第一次选择跳2级，则有f(n-2)种跳法，即跳n级台阶总共有f(n) = f(n-1) +　f(n-2)种跳法。
可得表达式为
f(n) = 
- 1               (n = 1)
- 2               (n = 2)
- f(n-1) + f(n-2) (n > 2)

### 问题变种2：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，...，也可以跳上n级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法

第一次如果跳1级台阶，那么还剩n-1级台阶，即f(n-1)种跳法，...，第一次跳n-1级台阶，那么还剩1级台阶，即1种跳法，最后是第一次跳n级台阶，还剩0级台阶，即1种跳法。可得：  

f(n) = f(n-1) + f(n-2) + ... + f(2) + f(1) + f(0)  
同理可得：  

f(n-1) =        f(n-2) + ... + f(2) + f(1) + f(0)  
...  

f(3) = f(2) + f(1) + f(0) = 2 + 1 + 1 = 4  

f(2) =        f(1) + f(0) =     1 + 1 = 2  

f(1) = 1  

将f(n-1) = f(n-2) + ... + f(2) + f(1) + f(0) 代入
f(n) = f(n-1) + f(n-2) + ... + f(2) + f(1) + f(0)中，可得
f(n) = f(n-1) + f(n-1) = f(n-1) * 2

同理可得：
f(n-1) = f(n-2) * 2，代入到f(n) = f(n-1) * 2可得 f(n) = f(n-2) * 2 * 2 = f(n-2) * 2^2  

同理，继续分解得到：f(n) = f(n-(n-1)) * 2^(n-1) = f(1) * 2^(n-1) = 1 * 2^(n-1)  

得到最终的通项公式：f(n) = 2^(n-1)

**注意，题目有隐含条件n>0，计算跳上0级台阶是没有意义的，f(0)不存在**

### 问题变种3：用2＊1的小矩形横着或者竖着去覆盖更大的矩形，请问用8个2＊1的小矩形去无重复地覆盖一个2*8的大矩形，总共有多少种方法？
![Avatar](./pictures/斐波那契变种问题矩形填空.png)
如果用小矩形横着放在左上角，那么第二个需要填在左下角，剩下2*6的矩形，方法种数记为f(6)。如果用小矩形竖着放在左上角，那么第二个需要填在左下角，剩下2*7的矩形，方法种数记为f(7)。  
可得：f(8) = f(7) + f(6)，可以看出这是一个斐波那契数列问题。

来源：
[csdn 剑指offer面试题9：斐波那契数列及其拓展青蛙跳台阶问题 作者：newy](https://blog.csdn.net/qq_33958946/article/details/84557018)

### 问题变种４：想兑换100元钱，有1,2,5,10四种钱，问总共有多少兑换方法
