## 原理

- 用key生成HashCode
- 使用哈希函数将key映射到数组某个下标
- 哈希函数相当于给以一定规则将不同key划分到了不同区域。原本（无规律的）数据集合只能线性查找，但使用哈希函数则将查找限定在更小的一个明确的区域内
- 以一定空间换取一定时间

## 哈希函数

**特点**

- 确定性：相同的输入，得到相同的输出
- 哈希冲突：不同的输入值，可能得到相同的输出
- 不可逆性：从一个HashCode可能得到无数个不同明文，无法得知哪个明文对应这个HashCode
- 混淆特性：仅改变输入的部分值，一个具有强混淆特性的哈希函数会产生一个几乎完全不同的输出

## HashCode

生成方式
- int：直接使用
- 其他类型：取指向该对象的指针的地址

## Bucket



## 哈希冲突

指的是哈希函数将key映射到了数组相同的索引上。

如果没有冲突，可以直接映射得到对应的元素然后返回。

但是如果发生哈希冲突，则需要比较key（hashcode）是否一致（用于确定是否是同一个对象），**如果不一致则继续根据策略找下一个元素，直到key（hashcode）一致，才返回对应元素**

### 解决方案

##### 拉链法
在冲突的索引处创建列表，将发生冲突的key都装入到列表中（如果列表过长，可以采用高度平衡的二叉查找树来将时间复杂度从O(n)优化至O(logn))
##### 开放寻址法-线性探测
从冲突位置往后线性查找是否有空位，有就插入。超过哈希表尾部则环绕回到首部。
覆盖key基地址的集群称为key的主集群
缺点：经过的线性探测次数越多，主集群会越大，之后任何增删查操作都会变慢
##### 开放寻址法-二次方探测
从冲突位置偏移$1^2$，没有空位则改成偏移$2^2$**（注意不是在之前偏移的基础上再次偏移）**，以此类推，直到找到空位。超过哈希表尾部则环绕回到首部。
缺点：如果负载因子和散列表大小不满足条件，则可能永远无法找到空位。如果α<0.5且M是质数（> 3），那么我们总是可以使用二次探测找到一个空槽。 （α是加载因子，M是散列表大小）

我们将通过矛盾使用证据。 我们首先假设两个二次探测步骤：x和y，x！= y（假设x
h(v) + x*x = h(v) + y*y (mod M)
x*x = y*y (mod M)//从两边敲出h（v）
x*x - y*y = 0 (mod M) //将y * y移动到左边
(x-y)*(x+y) = 0 (mod M)//重新排列公式

现在，（x-y）或（x + y）必须等于零。 我们的假设是x != y,  那么（x-y）不能为0. 由于0≤ x
矛盾！
因此，第一个M / 2二次探测步骤不能产生相同的地址模M（如果我们将M设置为大于3的质数）

##### 开放寻址法-双重散列
如果冲突，则使用第二个

h(v)//基地址
(h(v)+ 1 * h2(v))％M //第一个探测步骤，如果有碰撞
(h(v)+ 2 * h2(v))％M //第2次探测步骤，如果仍有冲突
(h(v)+ 3 * h2(v))％M //第三次探测步骤，如果仍有冲突
...
(h(v)+ k * h2(v))％M //第k个探测步骤等...
就是这样，探测器根据第二个散列函数h2（v）的值跳转，根据需要环绕散列表。
通常（对于整数键），h2(v)= M' - v%M'其中M'是一个小于M的质数。这使得h2(v)∈[1..M']，它足够多样 二次聚类。
### 懒惰删除
删除时不直接移除，而是标记为Delete。添加时遇到则覆盖，获取时遇到则当作不存在。

参考：https://visualgo.net/zh/hashtable?slide=1
